Systemy oparte o message brokery, takie jak RabbitMQ, Apache Kafka, Amazon SQS czy Azure Service Bus, są kluczowe dla budowy skalowalnych i niezawodnych aplikacji rozproszonych. Oto kilka istotnych aspektów, które warto znać:

1. Idempotentność
Idempotentność oznacza, że przetwarzanie tej samej wiadomości więcej niż raz nie prowadzi do różnych rezultatów. Jest to ważne w przypadku systemów kolejkowych, które gwarantują co najmniej jednokrotne dostarczenie wiadomości (at-least-once delivery). Aby zapewnić idempotentność:

Unikalne identyfikatory: Każda wiadomość powinna mieć unikalny identyfikator, który jest sprawdzany przed przetworzeniem.
Transakcje: W niektórych przypadkach można użyć transakcji do zapewnienia, że operacja jest albo w pełni wykonana, albo wcale.
Deduplication: Niektóre brokery, jak Apache Kafka, oferują mechanizmy deduplikacji na poziomie brokera.

2. Problem producenta i konsumenta
Producent (producer) i konsument (consumer) to dwa główne komponenty systemu opartego na message brokerze. Wyzwania związane z nimi obejmują:

Backpressure (przepływ wsteczny): Jeśli producent generuje wiadomości szybciej niż konsument jest w stanie je przetwarzać, może dojść do przeciążenia systemu.
Skalowanie horyzontalne: Dodawanie nowych instancji konsumentów, które będą przetwarzać wiadomości równolegle.
Batch processing (przetwarzanie wsadowe): Pobieranie i przetwarzanie wiadomości w większych paczkach (chunkach), co może poprawić wydajność przetwarzania.
Rate limiting: Ograniczanie szybkości produkcji wiadomości, aby konsument miał czas na ich przetworzenie.

3. Delivery Guarantees (Gwarancje dostarczenia)
At-most-once: Wiadomość może zostać dostarczona najwyżej raz. Może to prowadzić do utraty wiadomości.
At-least-once: Wiadomość zostanie dostarczona co najmniej raz, co może prowadzić do duplikacji.
Exactly-once: Wiadomość zostanie dostarczona dokładnie raz. Jest to najtrudniejsze do osiągnięcia, ale niektóre systemy, jak Kafka z odpowiednią konfiguracją, mogą to zapewnić.

4. Konsystencja i trwałość
Durable queues: Kolejki trwałe zapisują wiadomości na dysku, co chroni przed utratą danych w przypadku awarii brokera.
Acknowledgements (potwierdzenia): Konsument potwierdza odbiór i przetworzenie wiadomości, co informuje brokera, że wiadomość może zostać usunięta z kolejki.

5. Kolejkowanie i routing wiadomości
FIFO (First-In-First-Out): Wiadomości są przetwarzane w takiej kolejności, w jakiej zostały dodane.
Priority queues: Kolejki z priorytetami umożliwiają przetwarzanie ważniejszych wiadomości przed innymi.
Topic-based routing: Wiadomości są kierowane na podstawie tematów, co pozwala na selektywne subskrypcje.

6. Monitoring i zarządzanie
Monitoring: Ważne jest monitorowanie zarówno stanu kolejek, jak i wydajności producentów i konsumentów.
Metryki: Liczba wiadomości w kolejce, czas przetwarzania wiadomości, liczba błędów itp.
Alerty: System powinien generować alerty w przypadku przeciążeń, opóźnień lub błędów.

7. Bezpieczeństwo
Autoryzacja i uwierzytelnianie: Zapewnienie, że tylko uprawnione aplikacje i użytkownicy mogą produkować i konsumować wiadomości.
Szyfrowanie: Zarówno transmisja (TLS), jak i przechowywanie (szyfrowanie danych na dysku) powinny być odpowiednio zabezpieczone.
Zrozumienie tych aspektów pomoże w skutecznym projektowaniu i implementacji systemów opartych na message brokerach, zapewniając ich niezawodność, skalowalność i bezpieczeństwo.



Azure Service Bus:

Azure Service Bus to usługa komunikacyjna w chmurze Azure, umożliwiająca przesyłanie wiadomości pomiędzy różnymi aplikacjami lub usługami. Jest to rozwiązanie typu 
„enterprise messaging”, które pozwala na tworzenie skalowalnych i niezawodnych rozwiązań integracyjnych. W ramach Azure Service Bus dostępne są trzy główne topologie komunikacyjne:

1. Queues (Kolejki)
	Opis: Kolejki działają w modelu point-to-point, co oznacza, że każda wiadomość jest odbierana tylko przez jednego konsumenta. Producent wysyła wiadomości do kolejki, 
	a jeden z odbiorców (konsumentów) pobiera wiadomość do przetworzenia.
	Zastosowanie: Kolejki są idealne w scenariuszach, gdzie istnieje potrzeba zbuforowania lub rozłożenia w czasie przetwarzania wiadomości, np. w aplikacjach z dużym obciążeniem, 
	które wymagają rozproszonego przetwarzania.
	Funkcje:
	Kolejkowanie wiadomości w trybie „first-in, first-out” (FIFO).
	Umożliwienie skalowania aplikacji, dodając więcej odbiorców.

2. Topics and Subscriptions (Tematy i subskrypcje)
	Opis: Tematy działają w modelu publish-subscribe (pub/sub). Producent publikuje wiadomości do tematu, a subskrybenci mogą zapisywać się na wybrane tematy. 
	Każdy subskrybent otrzymuje swoją kopię wiadomości, niezależnie od tego, ilu subskrybentów istnieje.
	Zastosowanie: Idealne w sytuacjach, gdzie wiadomość musi być odbierana przez wiele niezależnych konsumentów, np. w systemach monitorowania, alertowania, dystrybucji informacji.
	Funkcje:
	Możliwość definiowania filtrów i reguł, które decydują, jakie wiadomości będą dostarczane do subskrybentów.
	Dostosowanie subskrypcji do różnych potrzeb aplikacji.

3. Relays (Przekaźniki)
	Opis: Przekaźniki działają w modelu hybrid i umożliwiają komunikację bezpośrednią pomiędzy aplikacjami w różnych lokalizacjach bez konieczności przechowywania wiadomości w 
	pośrednim buforze (jak to ma miejsce w przypadku kolejek czy tematów). Relay umożliwia połączenie aplikacji działających za firewallem, bez potrzeby otwierania dodatkowych portów.
	Zastosowanie: Relay jest często używany w scenariuszach integracji on-premises z chmurą, gdzie zachodzi potrzeba bezpośredniej komunikacji w czasie rzeczywistym.
	Funkcje:
	Zapewnia tunelowanie komunikacji między aplikacjami.
	Oparty na protokołach takich jak HTTP lub WebSocket.

Dodatkowe funkcje Azure Service Bus:
	Dead-letter queue (DLQ): Specjalne kolejki na wiadomości, które nie mogły być dostarczone lub przetworzone w odpowiednim czasie.
	
	Forwarding: Automatyczne przekierowywanie wiadomości między różnymi kolejkami lub tematami.
	
	Session-based messaging: Możliwość grupowania wiadomości w sesje dla zapewnienia odpowiedniego porządku przetwarzania.
	Azure Service Bus jest użytecznym rozwiązaniem dla rozproszonej architektury mikroserwisowej, szczególnie w scenariuszach wymagających niezawodnego przesyłania wiadomości 
	i skalowalności.